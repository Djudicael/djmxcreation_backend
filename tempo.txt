// Refactored to use tokio_postgres instead of sqlx
use crate::{
    config::db::{ClientV2, DbV2},
    entity::about_me::AboutMe,
    error::to_error,
};
use app_core::{
    about_me::about_me_repository::IAboutMeRepository,
    dto::{about_me_dto::AboutMeDto, content_dto::ContentDto},
};
use app_error::Error;
use async_trait::async_trait;
use serde_json::json;

pub struct AboutMeRepository {
    client: ClientV2,
}

impl AboutMeRepository {
    pub fn new(client: ClientV2) -> Self {
        Self { client }
    }

    // Helper function to execute queries with error mapping
    async fn execute_query<T>(&self, query: &str, params: &[&(dyn tokio_postgres::types::ToSql + Sync)]) -> Result<T, Error>
    where
        T: tokio_postgres::types::FromSqlOwned,
    {
        let stmt = self.client.prepare(query).await.map_err(|e| to_error(e, None))?;
        let rows = self.client.query_one(&stmt, params).await.map_err(|e| to_error(e, None))?;
        Ok(rows.get(0))
    }
}

#[async_trait]
impl IAboutMeRepository for AboutMeRepository {
    async fn update_about_me(&self, id: i32, about: &AboutMeDto) -> Result<AboutMeDto, Error> {
        let sql = "UPDATE about SET first_name = $1, last_name = $2, description = $3 WHERE id = $4 RETURNING id, first_name, last_name, description";
        let AboutMeDto {
            first_name,
            last_name,
            description,
            ..
        } = about.clone();

        let stmt = self.client.prepare(sql).await.map_err(|e| to_error(e, Some(id.to_string())))?;
        let row = self
            .client
            .query_one(&stmt, &[&first_name, &last_name, &description, &id])
            .await
            .map_err(|e| to_error(e, Some(id.to_string())))?;

        Ok(AboutMeDto::from_row(&row))
    }

    async fn get_about_me(&self) -> Result<AboutMeDto, Error> {
        let sql = "SELECT * FROM about LIMIT 1";
        let stmt = self.client.prepare(sql).await.map_err(|e| to_error(e, None))?;
        let row = self.client.query_one(&stmt, &[]).await.map_err(|e| to_error(e, None))?;
        Ok(AboutMeDto::from_row(&row))
    }

    async fn get_about_me_by_id(&self, id: i32) -> Result<AboutMeDto, Error> {
        let sql = "SELECT * FROM about WHERE id = $1";
        let stmt = self.client.prepare(sql).await.map_err(|e| to_error(e, Some(id.to_string())))?;
        let row = self.client.query_one(&stmt, &[&id]).await.map_err(|e| to_error(e, Some(id.to_string())))?;
        Ok(AboutMeDto::from_row(&row))
    }

    async fn update_photo(&self, id: i32, content: &ContentDto) -> Result<(), Error> {
        let sql = "UPDATE about SET photo = $1 WHERE id = $2";
        let content_json = json!(content);

        let stmt = self.client.prepare(sql).await.map_err(|e| to_error(e, Some(id.to_string())))?;
        self.client
            .execute(&stmt, &[&content_json, &id])
            .await
            .map_err(|e| to_error(e, Some(id.to_string())))?;
        Ok(())
    }

    async fn delete_about_me_photo(&self, id: i32) -> Result<(), Error> {
        let sql = "UPDATE about SET photo = NULL WHERE id = $1";
        let stmt = self.client.prepare(sql).await.map_err(|e| to_error(e, Some(id.to_string())))?;
        self.client
            .execute(&stmt, &[&id])
            .await
            .map_err(|e| to_error(e, Some(id.to_string())))?;
        Ok(())
    }
}
